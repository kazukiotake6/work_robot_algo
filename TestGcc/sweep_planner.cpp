#include "sweep_planner.h"
#include <algorithm> // For std::min_element, std::max_element used in bounding box calculation
#include <vector>    // For std::vector (though already included via headers)
#include <limits>    // For std::numeric_limits, used for initializing min/max values

// Constructor: Initializes the planner with the area to mow and the cutting width.
SweepPathPlanner::SweepPathPlanner(const Polygon& area, double cutting_width)
    : area_to_mow_(area), cutting_width_(cutting_width) {
    // Ensure the waypoints vector is initially empty.
    waypoints_.clear();
}

// Generates a sweep path for the given area.
// Assumption: The area_to_mow_ is an axis-aligned rectangle for this implementation.
// The path consists of horizontal sweeps, alternating direction (boustrophedon).
std::vector<Point> SweepPathPlanner::generatePath() {
    waypoints_.clear(); // Clear any previously generated waypoints.

    // Validate input: area must have vertices and cutting width must be positive.
    if (area_to_mow_.vertices.empty() || cutting_width_ <= 0.0) {
        return waypoints_; // Return empty path for invalid inputs.
    }

    // 1. Calculate the bounding box of the polygon.
    // For a general polygon, this would be the min/max x and y coordinates of its vertices.
    // For the assumed axis-aligned rectangle, these correspond to its corner coordinates.
    // Initialize min/max with extreme values.
    double min_x = std::numeric_limits<double>::max();
    double max_x = std::numeric_limits<double>::lowest(); // Smallest possible double
    double min_y = std::numeric_limits<double>::max();
    double max_y = std::numeric_limits<double>::lowest();

    // Iterate through vertices to find the actual min/max coordinates.
    for (const auto& v : area_to_mow_.vertices) {
        if (v.x < min_x) min_x = v.x;
        if (v.x > max_x) max_x = v.x;
        if (v.y < min_y) min_y = v.y;
        if (v.y > max_y) max_y = v.y;
    }

    // Validate the calculated bounding box.
    // If min_x >= max_x or min_y >= max_y, the polygon is degenerate (e.g., a line or point) or invalid.
    if (min_x >= max_x || min_y >= max_y) {
        return waypoints_; // Return empty path for a degenerate area.
    }

    // 2. Determine starting Y-coordinate and sweep direction.
    // The first sweep line is offset from the bottom edge (min_y) by half the cutting width,
    // so the center of the mower follows this line.
    double current_y = min_y + cutting_width_ / 2.0;
    bool going_left_to_right = true; // Start sweeping from left (min_x) to right (max_x).

    // 3. Generate horizontal sweep lines (waypoints).
    // Continue generating sweeps as long as the center of the mower is within the upper boundary.
    // The upper boundary for the center of the mower is max_y minus half the cutting width.
    while (current_y <= max_y - cutting_width_ / 2.0) {
        if (going_left_to_right) {
            // Add start point (left edge) and end point (right edge) of the sweep.
            waypoints_.emplace_back(min_x, current_y);
            waypoints_.emplace_back(max_x, current_y);
        } else {
            // Add start point (right edge) and end point (left edge) of the sweep.
            waypoints_.emplace_back(max_x, current_y);
            waypoints_.emplace_back(min_x, current_y);
        }
        // Move to the next sweep line, up by one full cutting width.
        current_y += cutting_width_;
        // Alternate the sweep direction for the next pass.
        going_left_to_right = !going_left_to_right;
    }
    
    // 4. Handle cases where the area's height is less than the cutting width.
    // If no waypoints were generated by the loop (e.g., total height < cutting_width_),
    // and the area is valid (has width and height), generate a single pass through the middle.
    if (waypoints_.empty() && (max_y > min_y) && (min_x < max_x) ) {
        // Calculate the Y-coordinate for a single pass in the middle of the area.
        double middle_y = (min_y + max_y) / 2.0;
        
        // Ensure this middle_y is actually within the bounds (should be, but good for robustness).
        // This condition also implicitly checks if min_y < max_y.
        if (middle_y >= min_y && middle_y <= max_y) { 
             waypoints_.emplace_back(min_x, middle_y);
             waypoints_.emplace_back(max_x, middle_y);
        }
    }

    return waypoints_; // Return the generated list of waypoints.
}

// Returns a const reference to the stored waypoints.
// This allows access to the path generated by the last call to generatePath().
const std::vector<Point>& SweepPathPlanner::getWaypoints() const {
    return waypoints_;
}
